<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Smt" rel="Chapter" href="Smt.html">
<link title="Hstring" rel="Chapter" href="Hstring.html"><title>Index of values</title>
</head>
<body>
<center><h1>Index of values</h1></center>
<table>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Smt.Type.html#VALall_constructors">all_constructors</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
<code class="code">all_constructors ()</code> returns a list of all the defined constructors.
</div>
</td></tr>
<tr><td><a href="Smt.Variant.html#VALassign_constr">assign_constr</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">assign_constr s cstr</code> will add the constraint that the constructor 
        <code class="code">cstr</code> must be in the type of <code class="code">s</code>
</div>
</td></tr>
<tr><td><a href="Smt.Variant.html#VALassign_var">assign_var</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">assign_var x y</code> will add the constraint that the type of <code class="code">y</code> is a
        subtype of <code class="code">x</code> (use this function when <code class="code">x := y</code> appear in your 
        program
</div>
</td></tr>
<tr><td><a href="Smt.Solver.html#VALassume">assume</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">assume ~profiling:b f id</code> adds the formula <code class="code">f</code> to the context of the
      solver with idetifier <code class="code">id</code>.
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Smt.Solver.html#VALcheck">check</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">check ()</code> runs Alt-Ergo Zero on its context.
</div>
</td></tr>
<tr><td><a href="Smt.Solver.html#VALclear">clear</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">clear ()</code> clears the context of the solver.
</div>
</td></tr>
<tr><td><a href="Smt.Variant.html#VALclose">close</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">close ()</code> will compute the smallest type possible for each symbol.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALcompare">compare</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">compares x y</code> returns <code class="code">0</code> if <code class="code">x</code> and <code class="code">y</code> are equal, and is unspecified
    otherwise but provides a total ordering on hash-consed strings.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALcompare_list">compare_list</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">compare_list l1 l2</code> returns <code class="code">0</code> if and only if <code class="code">l1</code> is equal to <code class="code">l2</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALconstructors">constructors</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
<code class="code">constructors ty</code> returns the list of constructors of <code class="code">ty</code> when type is
      an enumerated data-type, otherwise returns <code class="code">[]</code>.
</div>
</td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Smt.Symbol.html#VALdeclare">declare</a> [<a href="Smt.Symbol.html">Smt.Symbol</a>]</td>
<td><div class="info">
<code class="code">declare s [arg_1; ... ; arg_n] out</code> declares a new function
      symbol with type <code class="code"> (arg_1, ... , arg_n) -&gt; out</code>
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALdeclare">declare</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
 <code class="code">declare n cstrs</code> declares a new enumerated data-type with
      name <code class="code">n</code> and constructors <code class="code">cstrs</code>., <code class="code">declare n []</code> declares a new abstract type with name <code class="code">n</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Symbol.html#VALdeclared">declared</a> [<a href="Smt.Symbol.html">Smt.Symbol</a>]</td>
<td><div class="info">
<code class="code">declared x</code> is <code class="code">true</code> if <code class="code">x</code> is already declared.
</div>
</td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Hstring.html#VALempty">empty</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
the empty (<code class="code">""</code>) hash-consed string.
</div>
</td></tr>
<tr><td><a href="Smt.Solver.html#VALentails">entails</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">entails ~id f</code> returns <code class="code">true</code> if the context of the solver entails
      the formula <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALequal">equal</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">equal x y</code> returns <code class="code">true</code> if <code class="code">x</code> and <code class="code">y</code> are the same hash-consed string
    (constant time).
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Smt.Formula.html#VALf_false">f_false</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
The formula which represents <code class="code">false</code>
</div>
</td></tr>
<tr><td><a href="Smt.Formula.html#VALf_true">f_true</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
The formula which represents <code class="code">true</code>
</div>
</td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Smt.Solver.html#VALget_calls">get_calls</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">get_calls ()</code> returns the cumulated number of calls to <a href="Smt.Solver.html#VALcheck"><code class="code">Smt.Solver.check</code></a>.
</div>
</td></tr>
<tr><td><a href="Smt.Solver.html#VALget_time">get_time</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">get_time ()</code> returns the cumulated time spent in the solver in seconds.
</div>
</td></tr>
<tr><td><a href="Smt.Variant.html#VALget_variants">get_variants</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">get_variants s</code> returns a set of constructors, which is the refined
      type of <code class="code">s</code>.
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="Smt.Symbol.html#VALhas_abstract_type">has_abstract_type</a> [<a href="Smt.Symbol.html">Smt.Symbol</a>]</td>
<td><div class="info">
<code class="code">has_abstract_type x</code> is <code class="code">true</code> if the type of x is abstract.
</div>
</td></tr>
<tr><td><a href="Smt.Symbol.html#VALhas_type_proc">has_type_proc</a> [<a href="Smt.Symbol.html">Smt.Symbol</a>]</td>
<td><div class="info">
<code class="code">has_type_proc x</code> is <code class="code">true</code> if x has the type of a process
      identifier.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALhash">hash</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">hash x</code> returns the integer (hash) associated to <code class="code">x</code>.
</div>
</td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Smt.Variant.html#VALinit">init</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">init l</code> where <code class="code">l</code> is a list of pairs <code class="code">(s, ty)</code> initializes the
      type (and associated constructors) of each <code class="code">s</code> to its original type <code class="code">ty</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALis_int">is_int</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">is_int x</code> is <code class="code">true</code> if the term <code class="code">x</code> has type int
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALis_real">is_real</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">is_real x</code> is <code class="code">true</code> if the term <code class="code">x</code> has type real
</div>
</td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Hstring.html#VALlist_assoc">list_assoc</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">list_assoc x l</code> returns the element associated with <code class="code">x</code> in the list of
    pairs <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALlist_mem">list_mem</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">list_mem x l</code> is <code class="code">true</code> if and only if <code class="code">x</code> is equal to an element of <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALlist_mem_assoc">list_mem_assoc</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
Same as <a href="Hstring.html#VALlist_assoc"><code class="code">Hstring.list_assoc</code></a>, but simply returns <code class="code">true</code> if a binding exists, and
    <code class="code">false</code> if no bindings exist for the given key.
</div>
</td></tr>
<tr><td><a href="Hstring.html#VALlist_mem_couple">list_mem_couple</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">list_mem_couple (x,y) l</code> is <code class="code">true</code> if and only if <code class="code">(x,y)</code> is equal to an
    element of <code class="code">l</code>.
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="Hstring.html#VALmake">make</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">make s</code> builds ans returns a hash-consed string from <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Formula.html#VALmake">make</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
<code class="code">make cmb [f_1; ...; f_n]</code> creates the formula
      <code class="code">(f_1 &lt;cmb&gt; ... &lt;cmb&gt; f_n)</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALmake_app">make_app</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">make_app f l</code> creates the application of function symbol <code class="code">f</code> to a list
      of terms <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALmake_arith">make_arith</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">make_arith op t1 t2</code> creates the term <code class="code">t1 &lt;op&gt; t2</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Formula.html#VALmake_cnf">make_cnf</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
<code class="code">make_cnf f</code> returns a conjunctive normal form of <code class="code">f</code> under the form: a
      list (which is a conjunction) of lists (which are disjunctions) of
      literals.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALmake_int">make_int</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">make_int n</code> creates an integer constant of value <code class="code">n</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALmake_ite">make_ite</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">make_ite f t1 t2</code> creates the term <code class="code">if f then t1 else t2</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Formula.html#VALmake_lit">make_lit</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
<code class="code">make_lit cmp [t1; t2]</code> creates the literal <code class="code">(t1 &lt;cmp&gt; t2)</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALmake_real">make_real</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">make_real n</code> creates an real constant of value <code class="code">n</code>.
</div>
</td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Hstring.html#VALprint">print</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
Prints a list of hash-consed strings on a formatter.
</div>
</td></tr>
<tr><td><a href="Smt.Formula.html#VALprint">print</a> [<a href="Smt.Formula.html">Smt.Formula</a>]</td>
<td><div class="info">
<code class="code">print fmt f</code> prints the formula on the formatter <code class="code">fmt</code>.
</div>
</td></tr>
<tr><td><a href="Smt.Variant.html#VALprint">print</a> [<a href="Smt.Variant.html">Smt.Variant</a>]</td>
<td><div class="info">
<code class="code">print ()</code> will output the computed refined types on std_err.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Smt.Solver.html#VALrestore_state">restore_state</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">restore_state s</code> restores a previously saved state <code class="code">s</code>.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Smt.Solver.html#VALsave_state">save_state</a> [<a href="Smt.Solver.html">Smt.Solver</a>]</td>
<td><div class="info">
<code class="code">save_state ()</code> returns a <b>copy</b> of the current state of the solver.
</div>
</td></tr>
<tr><td><a href="Smt.html#VALset_cc">set_cc</a> [<a href="Smt.html">Smt</a>]</td>
<td><div class="info">
set_cc <code class="code">false</code> deactivates congruence closure algorithm
    (<code class="code">true</code> by default).
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Smt.Term.html#VALt_false">t_false</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">t_false</code> is the boolean term <code class="code">false</code>
</div>
</td></tr>
<tr><td><a href="Smt.Term.html#VALt_true">t_true</a> [<a href="Smt.Term.html">Smt.Term</a>]</td>
<td><div class="info">
<code class="code">t_true</code> is the boolean term <code class="code">true</code>
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALtype_bool">type_bool</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
The type of booleans
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALtype_int">type_int</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
The type of integers
</div>
</td></tr>
<tr><td><a href="Smt.Symbol.html#VALtype_of">type_of</a> [<a href="Smt.Symbol.html">Smt.Symbol</a>]</td>
<td><div class="info">
<code class="code">type_of x</code> returns the type of x.
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALtype_proc">type_proc</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
The type processes (identifiers)
</div>
</td></tr>
<tr><td><a href="Smt.Type.html#VALtype_real">type_real</a> [<a href="Smt.Type.html">Smt.Type</a>]</td>
<td><div class="info">
The type of reals
</div>
</td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Hstring.html#VALview">view</a> [<a href="Hstring.html">Hstring</a>]</td>
<td><div class="info">
<code class="code">view hs</code> returns the string corresponding to <code class="code">hs</code>.
</div>
</td></tr>
</table><br>
</body>
</html>